{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"News Network Tone Analysis\"\n",
        "author: \"Kristin Lloyd\"\n",
        "format: \n",
        "  html:\n",
        "    code-fold: true\n",
        "    toc: true\n",
        "execute:\n",
        "  warning: false\n",
        "  message: false\n",
        "---"
      ],
      "id": "2ecff62c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import glob\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "import seaborn as sns\n",
        "from collections import Counter\n",
        "from scipy.stats import ttest_ind\n",
        "import matplotlib.dates as mdates\n",
        "from matplotlib.ticker import MaxNLocator\n",
        "\n",
        "plt.style.use('seaborn-v0_8-whitegrid')\n",
        "plt.rcParams['font.family'] = 'sans-serif'\n",
        "plt.rcParams['font.sans-serif'] = ['Arial', 'DejaVu Sans', 'Liberation Sans']\n",
        "\n",
        "# Define network colors\n",
        "NETWORK_COLORS = {\n",
        "    'Fox News': '#E41A1C',    # Red for Fox\n",
        "    'MSNBC': '#377EB8',       # Blue for MSNBC\n",
        "    'ABC News': '#984EA3'     # Purple for ABC\n",
        "}\n",
        "\n",
        "# Import data files\n",
        "csv_files = (\n",
        "    glob.glob(\"../data/fox/fox*.csv\") +\n",
        "    glob.glob(\"../data/abc/abc*.csv\") +\n",
        "    glob.glob(\"../data/msnbc/msnbc*.csv\")\n",
        ")\n",
        "\n",
        "# Read with fallback for encoding issues\n",
        "dfs = []\n",
        "for file in csv_files:\n",
        "    try:\n",
        "        dfs.append(pd.read_csv(file))\n",
        "    except UnicodeDecodeError:\n",
        "        dfs.append(pd.read_csv(file, encoding='latin1'))\n",
        "\n",
        "df = pd.concat(dfs, ignore_index=True)\n",
        "\n",
        "# Select relevant columns\n",
        "columns_of_interest = [\n",
        "    \"parsed_date\", \"url\", \"headline_from_url\",\n",
        "    \"V2Themes\", \"V2Locations\", \"V2Persons\",\n",
        "    \"V2Organizations\", \"V2Tone\",\n",
        "    \"afinn_tone_score\", \"vader_tone_score\", \"sentiment_label\"\n",
        "]\n",
        "\n",
        "df = df[columns_of_interest]\n",
        "\n",
        "# Convert date and extract network information\n",
        "df[\"parsed_date\"] = pd.to_datetime(df[\"parsed_date\"], errors=\"coerce\").dt.tz_localize(None)\n",
        "\n",
        "# Extract network source from URLs\n",
        "def extract_network(url):\n",
        "    try:\n",
        "        url = url.lower()\n",
        "        if 'fox' in url:\n",
        "            return 'Fox News'\n",
        "        elif 'abc' in url:\n",
        "            return 'ABC News'\n",
        "        elif 'msnbc' in url:\n",
        "            return 'MSNBC'\n",
        "        else:\n",
        "            return 'Unknown'\n",
        "    except AttributeError:\n",
        "        return 'Unknown'\n",
        "\n",
        "# Add network column\n",
        "df['network'] = df['url'].apply(extract_network)\n",
        "\n",
        "# Extract tone components\n",
        "tone_split = df[\"V2Tone\"].str.split(\",\", expand=True)\n",
        "df[\"tone\"] = pd.to_numeric(tone_split[0], errors=\"coerce\")\n",
        "df[\"positive_score\"] = pd.to_numeric(tone_split[1], errors=\"coerce\")\n",
        "df[\"negative_score\"] = pd.to_numeric(tone_split[2], errors=\"coerce\")\n",
        "\n",
        "# Create month and year columns for aggregation\n",
        "df['month'] = df['parsed_date'].dt.to_period('M')\n",
        "df['year'] = df['parsed_date'].dt.year\n",
        "df['month_year'] = df['parsed_date'].dt.strftime('%Y-%m')"
      ],
      "id": "04b74daf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from datetime import timedelta\n",
        "\n",
        "elections = {\n",
        "    \"2016\": pd.to_datetime(\"2016-11-08\"),\n",
        "    \"2020\": pd.to_datetime(\"2020-11-03\"),\n",
        "    \"2024\": pd.to_datetime(\"2024-11-05\")\n",
        "}\n",
        "\n",
        "# Add flag for period around each election\n",
        "election_windows = []\n",
        "for year, date in elections.items():\n",
        "    df_sub = df[\n",
        "        (df[\"parsed_date\"] >= date - timedelta(days=30)) &\n",
        "        (df[\"parsed_date\"] <= date + timedelta(days=30))\n",
        "    ].copy()\n",
        "    df_sub[\"election_year\"] = year\n",
        "    df_sub[\"period\"] = np.where(\n",
        "        df_sub[\"parsed_date\"] < date, \"Before\", \"After\"\n",
        "    )\n",
        "    election_windows.append(df_sub)\n",
        "\n",
        "df_elections = pd.concat(election_windows)"
      ],
      "id": "5c8ff701",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df_elections = df_elections[[\n",
        "    \"parsed_date\", \"network\", \"election_year\", \"period\",\n",
        "    \"tone\", \"afinn_tone_score\", \"vader_tone_score\"\n",
        "]]"
      ],
      "id": "3cda1ce9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Reshape the data for plotting\n",
        "df_long = df_elections.melt(\n",
        "    id_vars=[\"parsed_date\", \"network\", \"election_year\", \"period\"],\n",
        "    value_vars=[\"tone\", \"afinn_tone_score\", \"vader_tone_score\"],\n",
        "    var_name=\"model\",\n",
        "    value_name=\"score\"\n",
        ")"
      ],
      "id": "91633779",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import glob\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "import seaborn as sns\n",
        "from collections import Counter\n",
        "from scipy.stats import ttest_ind\n",
        "import matplotlib.dates as mdates\n",
        "from matplotlib.ticker import MaxNLocator\n",
        "from datetime import timedelta\n",
        "\n",
        "# Set visualization style\n",
        "plt.style.use('seaborn-v0_8-whitegrid')\n",
        "plt.rcParams['font.family'] = 'sans-serif'\n",
        "plt.rcParams['font.sans-serif'] = ['Arial', 'DejaVu Sans', 'Liberation Sans']\n",
        "\n",
        "# Define network colors\n",
        "NETWORK_COLORS = {\n",
        "    'Fox News': '#E41A1C',    # Red for Fox\n",
        "    'MSNBC': '#377EB8',       # Blue for MSNBC\n",
        "    'ABC News': '#984EA3'     # Purple for ABC\n",
        "}\n",
        "\n",
        "# Import data files\n",
        "csv_files = (\n",
        "    glob.glob(\"../data/fox/fox*.csv\") +\n",
        "    glob.glob(\"../data/abc/abc*.csv\") +\n",
        "    glob.glob(\"../data/msnbc/msnbc*.csv\")\n",
        ")\n",
        "\n",
        "# Read CSVs safely with fallback\n",
        "dfs = []\n",
        "for file in csv_files:\n",
        "    try:\n",
        "        dfs.append(pd.read_csv(file))\n",
        "    except UnicodeDecodeError:\n",
        "        dfs.append(pd.read_csv(file, encoding=\"latin1\"))\n",
        "\n",
        "df = pd.concat(dfs, ignore_index=True)\n",
        "\n",
        "# Select relevant columns\n",
        "columns_of_interest = [\n",
        "    \"parsed_date\", \"url\", \"headline_from_url\",\n",
        "    \"V2Themes\", \"V2Locations\", \"V2Persons\",\n",
        "    \"V2Organizations\", \"V2Tone\",\n",
        "    \"afinn_tone_score\", \"vader_tone_score\", \"sentiment_label\"\n",
        "]\n",
        "\n",
        "df = df[columns_of_interest]\n",
        "\n",
        "# Convert date and extract network information\n",
        "df[\"parsed_date\"] = pd.to_datetime(df[\"parsed_date\"], errors=\"coerce\").dt.tz_localize(None)\n",
        "\n",
        "# Extract network source from URLs\n",
        "def extract_network(url):\n",
        "    try:\n",
        "        url = url.lower()\n",
        "        if 'fox' in url:\n",
        "            return 'Fox News'\n",
        "        elif 'abc' in url:\n",
        "            return 'ABC News'\n",
        "        elif 'msnbc' in url:\n",
        "            return 'MSNBC'\n",
        "        else:\n",
        "            return 'Unknown'\n",
        "    except AttributeError:\n",
        "        return 'Unknown'\n",
        "\n",
        "# Add network column\n",
        "df['network'] = df['url'].apply(extract_network)\n",
        "\n",
        "# Extract tone components\n",
        "tone_split = df[\"V2Tone\"].str.split(\",\", expand=True)\n",
        "df[\"tone\"] = pd.to_numeric(tone_split[0], errors=\"coerce\")\n",
        "df[\"positive_score\"] = pd.to_numeric(tone_split[1], errors=\"coerce\")\n",
        "df[\"negative_score\"] = pd.to_numeric(tone_split[2], errors=\"coerce\")\n",
        "\n",
        "# Create month and year columns for aggregation\n",
        "df['month'] = df['parsed_date'].dt.to_period('M')\n",
        "df['year'] = df['parsed_date'].dt.year\n",
        "df['month_year'] = df['parsed_date'].dt.strftime('%Y-%m')\n",
        "\n",
        "# Define election dates\n",
        "elections = {\n",
        "    \"2016\": pd.to_datetime(\"2016-11-08\"),\n",
        "    \"2020\": pd.to_datetime(\"2020-11-03\"),\n",
        "    \"2024\": pd.to_datetime(\"2024-11-05\")\n",
        "}\n",
        "\n",
        "# Add flag for period around each election\n",
        "election_windows = []\n",
        "for year, date in elections.items():\n",
        "    df_sub = df[\n",
        "        (df[\"parsed_date\"] >= date - timedelta(days=30)) &\n",
        "        (df[\"parsed_date\"] <= date + timedelta(days=30))\n",
        "    ].copy()\n",
        "    df_sub[\"election_year\"] = year\n",
        "    df_sub[\"period\"] = np.where(\n",
        "        df_sub[\"parsed_date\"] < date, \"Before\", \"After\"\n",
        "    )\n",
        "    election_windows.append(df_sub)\n",
        "\n",
        "df_elections = pd.concat(election_windows)\n",
        "\n",
        "df_elections = df_elections[[\n",
        "    \"parsed_date\", \"network\", \"election_year\", \"period\",\n",
        "    \"tone\", \"afinn_tone_score\", \"vader_tone_score\"\n",
        "]]\n",
        "\n",
        "# Function to normalize values based on theoretical ranges\n",
        "def normalize_score_theoretical(series, min_val, max_val):\n",
        "    return (series - min_val) / (max_val - min_val)\n",
        "\n",
        "# Standard theoretical ranges for each sentiment measure\n",
        "# GDELT Tone: typically ranges from -100 to +100\n",
        "# AFINN: ranges from -5 to +5 per word, but articles can have wide ranges like -500 to +500\n",
        "# VADER: ranges from -1 to +1\n",
        "\n",
        "# Create normalized versions using theoretical ranges\n",
        "df_elections['tone_normalized'] = normalize_score_theoretical(df_elections['tone'], -100, 100)\n",
        "df_elections['afinn_normalized'] = normalize_score_theoretical(df_elections['afinn_tone_score'], -500, 500)\n",
        "df_elections['vader_normalized'] = normalize_score_theoretical(df_elections['vader_tone_score'], -1, 1)\n",
        "\n",
        "# Clip values to ensure they fall within 0-1 range (in case of outliers beyond theoretical ranges)\n",
        "df_elections['tone_normalized'] = df_elections['tone_normalized'].clip(0, 1)\n",
        "df_elections['afinn_normalized'] = df_elections['afinn_normalized'].clip(0, 1)\n",
        "df_elections['vader_normalized'] = df_elections['vader_normalized'].clip(0, 1)\n",
        "\n",
        "# Reshape the data for plotting with normalized scores\n",
        "df_long_normalized = df_elections.melt(\n",
        "    id_vars=[\"parsed_date\", \"network\", \"election_year\", \"period\"],\n",
        "    value_vars=[\"tone_normalized\", \"afinn_normalized\", \"vader_normalized\"],\n",
        "    var_name=\"model\",\n",
        "    value_name=\"score\"\n",
        ")\n",
        "\n",
        "# Update the model names for better readability\n",
        "df_long_normalized['model'] = df_long_normalized['model'].replace({\n",
        "    'tone_normalized': 'GDELT Tone',\n",
        "    'afinn_normalized': 'AFINN', \n",
        "    'vader_normalized': 'VADER'\n",
        "})\n",
        "\n",
        "# Set the visual style\n",
        "sns.set(style=\"whitegrid\", font_scale=1.1)\n",
        "\n",
        "# Create the boxplot with normalized scores\n",
        "plt.figure(figsize=(8, 5))\n",
        "ax = sns.boxplot(\n",
        "    x=\"model\", \n",
        "    y=\"score\", \n",
        "    data=df_long_normalized, \n",
        "    palette=\"Set2\", \n",
        "    showfliers=False\n",
        ")\n",
        "\n",
        "# Add original scale information as text annotation\n",
        "plt.figtext(\n",
        "    0.01, 0.01, \n",
        "    \"Original scales - GDELT: [-100, 100], AFINN: [-500, 500], VADER: [-1, 1]\",\n",
        "    fontsize=9\n",
        ")\n",
        "\n",
        "plt.title(\"Normalized Sentiment Score Comparison (All Elections & Networks)\", fontsize=14)\n",
        "plt.xlabel(\"Sentiment Model\")\n",
        "plt.ylabel(\"Normalized Score (0-1 scale)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "5bff12f3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The fact that VADER's distribution is skewed higher than the other two metrics suggests it might be detecting more positive sentiment in the same news content, or it could be that VADER's algorithm is more sensitive to certain types of positive language used in news reporting.\n",
        "\n",
        "It's also worth noting that GDELT and AFINN seem to have similar distributions despite using different scales and methodologies, which suggests they might be capturing similar sentiment patterns in the news articles.\n"
      ],
      "id": "03e7f7da"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "\n",
        "correlation = df_elections['tone'].corr(df_elections['afinn_tone_score'])\n",
        "\n",
        "scatter = plt.scatter(\n",
        "    df_elections['tone'], \n",
        "    df_elections['afinn_tone_score'],\n",
        "    alpha=0.5,\n",
        "    color='red' \n",
        ")\n",
        "\n",
        "# Add correlation information\n",
        "plt.annotate(\n",
        "    f'Correlation: {correlation:.3f}', \n",
        "    xy=(0.05, 0.95), \n",
        "    xycoords='axes fraction', \n",
        "    fontsize=8,\n",
        "    bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", alpha=0.8)\n",
        ")\n",
        "\n",
        "# Add a horizontal and vertical line at 0 to indicate neutral sentiment\n",
        "plt.axhline(y=0, color='blue', linestyle='--', alpha=0.7)\n",
        "plt.axvline(x=0, color='blue', linestyle='--', alpha=0.7)\n",
        "\n",
        "# Label the quadrants\n",
        "plt.text(df_elections['tone'].max()*0.7, df_elections['afinn_tone_score'].max()*0.7, \n",
        "         'Both Positive', fontsize=10, ha='center')\n",
        "plt.text(df_elections['tone'].min()*0.7, df_elections['afinn_tone_score'].max()*0.7, \n",
        "         'GDELT Negative\\nAFINN Positive', fontsize=8, ha='center')\n",
        "plt.text(df_elections['tone'].max()*0.7, df_elections['afinn_tone_score'].min()*0.7, \n",
        "         'GDELT Positive\\nAFINN Negative', fontsize=8, ha='center')\n",
        "plt.text(df_elections['tone'].min()*0.7, df_elections['afinn_tone_score'].min()*0.7, \n",
        "         'Both Negative', fontsize=10, ha='center')\n",
        "\n",
        "# Add labels and title\n",
        "plt.xlabel('GDELT Tone Score')\n",
        "plt.ylabel('AFINN Tone Score')\n",
        "plt.title('GDELT vs. AFINN Sentiment Comparison', fontsize=10)\n",
        "\n",
        "# Add a grid for better readability\n",
        "plt.grid(True, alpha=0.3)\n",
        "\n",
        "# Tight layout\n",
        "plt.tight_layout()\n",
        "\n",
        "# Show the plot\n",
        "plt.show()"
      ],
      "id": "57b7c610",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "A significant cluster of points falls in the \"Both Negative\" quadrant, confirming your observation that both GDELT and AFINN detect substantial negative sentiment in the news articles.\n",
        "\n",
        "There are very few points in the \"GDELT Positive, AFINN Negative\" quadrant, suggesting that when GDELT finds positive sentiment, AFINN rarely strongly disagrees.\n",
        "\n",
        "However, there are a fair number of points in the \"GDELT Negative, AFINN Positive\" quadrant, indicating some systematic differences in how these two metrics evaluate certain types of content.\n"
      ],
      "id": "4051cc21"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| label: fig-animated-monthly-tone\n",
        "#| fig-cap: Animated monthly average tone trends by news network (2015-2025)\n",
        "\n",
        "import plotly.graph_objects as go\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from plotly.subplots import make_subplots\n",
        "import datetime as dt\n",
        "\n",
        "# Network color definitions\n",
        "NETWORK_COLORS = {\n",
        "    'MSNBC': '#3366CC',\n",
        "    'ABC News': '#6633CC', \n",
        "    'Fox News': '#CC3366'\n",
        "}\n",
        "\n",
        "# Create the monthly tone data from df\n",
        "# Calculate the monthly averages\n",
        "monthly_tone = df.groupby(['month', 'network'])['tone'].mean().unstack()\n",
        "\n",
        "# Convert month period to datetime for plotting\n",
        "monthly_tone_reset = monthly_tone.reset_index()\n",
        "monthly_tone_reset['month_datetime'] = monthly_tone_reset['month'].dt.to_timestamp()\n",
        "\n",
        "# Create figure\n",
        "fig = go.Figure()\n",
        "\n",
        "# Add neutral line\n",
        "fig.add_shape(\n",
        "    type=\"line\",\n",
        "    x0=monthly_tone_reset['month_datetime'].min(),\n",
        "    x1=monthly_tone_reset['month_datetime'].max(),\n",
        "    y0=0,\n",
        "    y1=0,\n",
        "    line=dict(\n",
        "        color=\"black\",\n",
        "        width=2,\n",
        "        dash=\"dash\",\n",
        "    ),\n",
        "    name=\"Neutral Tone\"\n",
        ")\n",
        "\n",
        "# Set up the animation parameters\n",
        "num_frames = 60  # Number of frames in the animation\n",
        "animation_frames = []\n",
        "\n",
        "# Get min and max y-values for consistent axis scaling\n",
        "y_min = monthly_tone.min().min() - 0.5\n",
        "y_max = monthly_tone.max().max() + 0.5\n",
        "\n",
        "# Create frames for the animation\n",
        "for i in range(num_frames):\n",
        "    frame_data = []\n",
        "    # Calculate how much of the data to show in this frame\n",
        "    cutoff_idx = int((i + 1) * len(monthly_tone_reset) / num_frames)\n",
        "    \n",
        "    # If we're at the last frame, make sure we show all data\n",
        "    if i == num_frames - 1:\n",
        "        cutoff_idx = len(monthly_tone_reset)\n",
        "    \n",
        "    # Create a trace for each network\n",
        "    for column in monthly_tone.columns:\n",
        "        visible_data = monthly_tone_reset.iloc[:cutoff_idx]\n",
        "        \n",
        "        frame_data.append(\n",
        "            go.Scatter(\n",
        "                x=visible_data['month_datetime'],\n",
        "                y=visible_data[column],\n",
        "                mode=\"lines\",\n",
        "                name=column,\n",
        "                line=dict(color=NETWORK_COLORS[column], width=4),\n",
        "                showlegend=(i == num_frames - 1)  # Only show legend on the last frame\n",
        "            )\n",
        "        )\n",
        "    \n",
        "    # Add data for this frame\n",
        "    animation_frames.append(go.Frame(data=frame_data, name=f\"frame_{i}\"))\n",
        "\n",
        "# Add the final state to the initial figure (will be shown before animation starts)\n",
        "for column in monthly_tone.columns:\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=[monthly_tone_reset['month_datetime'].iloc[0]],  # Start with just the first point\n",
        "            y=[monthly_tone_reset[column].iloc[0]],\n",
        "            mode=\"lines\",\n",
        "            name=column,\n",
        "            line=dict(color=NETWORK_COLORS[column], width=4)\n",
        "        )\n",
        "    )\n",
        "\n",
        "# Update the figure layout\n",
        "fig.update_layout(\n",
        "    title=dict(\n",
        "        text=\"Monthly Average Tone by News Network (2015-2025)\",\n",
        "        font=dict(size=18, family=\"Arial, sans-serif\"),\n",
        "        x=0.5,\n",
        "        xanchor=\"center\"\n",
        "    ),\n",
        "    xaxis=dict(\n",
        "        title=\"Date\",\n",
        "        titlefont=dict(size=14),\n",
        "        tickformat=\"%Y\",  # Show just the year\n",
        "        gridcolor=\"#E5E5E5\",\n",
        "        showgrid=True\n",
        "    ),\n",
        "    yaxis=dict(\n",
        "        title=\"Average Tone Score\",\n",
        "        titlefont=dict(size=14),\n",
        "        gridcolor=\"#E5E5E5\",\n",
        "        showgrid=True,\n",
        "        range=[y_min, y_max]  # Consistent y-axis range\n",
        "    ),\n",
        "    legend=dict(\n",
        "        title=\"News Networks\",\n",
        "        orientation=\"h\",\n",
        "        y=-0.2,\n",
        "        x=0.5,\n",
        "        xanchor=\"center\"\n",
        "    ),\n",
        "    plot_bgcolor=\"white\",\n",
        "    width=900,\n",
        "    height=500,\n",
        "    margin=dict(l=50, r=50, t=80, b=100),\n",
        "    updatemenus=[\n",
        "        dict(\n",
        "            type=\"buttons\",\n",
        "            showactive=False,\n",
        "            buttons=[\n",
        "                dict(\n",
        "                    label=\"Play\",\n",
        "                    method=\"animate\",\n",
        "                    args=[\n",
        "                        None,\n",
        "                        dict(\n",
        "                            frame=dict(duration=100, redraw=True),\n",
        "                            fromcurrent=True,\n",
        "                            transition=dict(duration=50, easing=\"cubic-in-out\")\n",
        "                        )\n",
        "                    ]\n",
        "                ),\n",
        "                dict(\n",
        "                    label=\"Pause\",\n",
        "                    method=\"animate\",\n",
        "                    args=[\n",
        "                        [None],\n",
        "                        dict(\n",
        "                            frame=dict(duration=0, redraw=True),\n",
        "                            mode=\"immediate\",\n",
        "                            transition=dict(duration=0)\n",
        "                        )\n",
        "                    ]\n",
        "                )\n",
        "            ],\n",
        "            direction=\"left\",\n",
        "            pad=dict(r=10, t=10),\n",
        "            x=0.1,\n",
        "            y=-0.2,  # Moved down from y=0 to y=-0.2\n",
        "            xanchor=\"right\",\n",
        "            yanchor=\"top\"\n",
        "        )\n",
        "    ]\n",
        ")\n",
        "\n",
        "# Add frames to the figure\n",
        "fig.frames = animation_frames\n",
        "\n",
        "# Add presidential administration periods (shown as background color)\n",
        "administrations = [\n",
        "    {\"name\": \"Obama Admin\", \"start\": \"2015-01-01\", \"end\": \"2017-01-19\", \"color\": \"rgba(0, 112, 192, 0.1)\"},\n",
        "    {\"name\": \"Trump 1st Term\", \"start\": \"2017-01-20\", \"end\": \"2021-01-19\", \"color\": \"rgba(192, 0, 0, 0.1)\"},\n",
        "    {\"name\": \"Biden Admin\", \"start\": \"2021-01-20\", \"end\": \"2025-01-19\", \"color\": \"rgba(0, 112, 192, 0.1)\"},\n",
        "    {\"name\": \"Trump 2nd Term\", \"start\": \"2025-01-20\", \"end\": \"2025-03-31\", \"color\": \"rgba(192, 0, 0, 0.1)\"}\n",
        "]\n",
        "\n",
        "for admin in administrations:\n",
        "    fig.add_shape(\n",
        "        type=\"rect\",\n",
        "        x0=admin[\"start\"],\n",
        "        x1=admin[\"end\"],\n",
        "        y0=y_min,\n",
        "        y1=y_max,\n",
        "        fillcolor=admin[\"color\"],\n",
        "        line=dict(width=0),\n",
        "        layer=\"below\"\n",
        "    )\n",
        "    \n",
        "    # Add presidency annotations\n",
        "    fig.add_annotation(\n",
        "        x=pd.to_datetime(admin[\"start\"]) + (pd.to_datetime(admin[\"end\"]) - pd.to_datetime(admin[\"start\"])) / 2,\n",
        "        y=y_max - 0.3,\n",
        "        text=admin[\"name\"],\n",
        "        showarrow=False,\n",
        "        font=dict(size=10)\n",
        "    )\n",
        "\n",
        "# Show the figure\n",
        "fig.show()"
      ],
      "id": "fig-animated-monthly-tone",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| label: fig-static-monthly-afinn-clean\n",
        "#| fig-cap: Monthly average AFINN tone trends by news network (2015–2025)\n",
        "\n",
        "import plotly.graph_objects as go\n",
        "import pandas as pd\n",
        "\n",
        "# Ensure 'month' column is datetime\n",
        "df['month'] = df['month'].dt.to_timestamp()\n",
        "\n",
        "# Create a continuous monthly index\n",
        "all_months = pd.date_range(start=df['month'].min(), end=df['month'].max(), freq='MS')\n",
        "\n",
        "# Fill missing months and smooth across gaps\n",
        "monthly_afinn_full = (\n",
        "    df.set_index('month')\n",
        "      .groupby('network')['afinn_tone_score']\n",
        "      .resample('MS')\n",
        "      .mean()\n",
        "      .unstack(0)\n",
        "      .reindex(all_months)\n",
        "      .reset_index()\n",
        "      .rename(columns={'index': 'month'})\n",
        ")\n",
        "\n",
        "# Define colors\n",
        "NETWORK_COLORS = {\n",
        "    'MSNBC': '#3366CC',\n",
        "    'ABC News': '#6633CC',\n",
        "    'Fox News': '#CC3366'\n",
        "}\n",
        "\n",
        "# Get y-axis range\n",
        "y_min = monthly_afinn_full.iloc[:, 1:].min().min() - 0.5\n",
        "y_max = monthly_afinn_full.iloc[:, 1:].max().max() + 0.5\n",
        "\n",
        "# Create figure\n",
        "fig = go.Figure()\n",
        "\n",
        "# Plot each network's line\n",
        "for network in ['MSNBC', 'ABC News', 'Fox News']:\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=monthly_afinn_full['month'],\n",
        "            y=monthly_afinn_full[network],\n",
        "            mode=\"lines+markers\",\n",
        "            name=network,\n",
        "            line=dict(color=NETWORK_COLORS[network], width=4),\n",
        "            connectgaps=True\n",
        "        )\n",
        "    )\n",
        "\n",
        "# Neutral tone line at y=0\n",
        "fig.add_shape(\n",
        "    type=\"line\",\n",
        "    x0=monthly_afinn_full['month'].min(),\n",
        "    x1=monthly_afinn_full['month'].max(),\n",
        "    y0=0,\n",
        "    y1=0,\n",
        "    line=dict(color=\"black\", width=2, dash=\"dash\")\n",
        ")\n",
        "\n",
        "# Add administration shading\n",
        "administrations = [\n",
        "    {\"name\": \"Obama Admin\", \"start\": \"2015-01-01\", \"end\": \"2017-01-19\", \"color\": \"rgba(0, 112, 192, 0.1)\"},\n",
        "    {\"name\": \"Trump 1st Term\", \"start\": \"2017-01-20\", \"end\": \"2021-01-19\", \"color\": \"rgba(192, 0, 0, 0.1)\"},\n",
        "    {\"name\": \"Biden Admin\", \"start\": \"2021-01-20\", \"end\": \"2025-01-19\", \"color\": \"rgba(0, 112, 192, 0.1)\"},\n",
        "    {\"name\": \"Trump 2nd Term\", \"start\": \"2025-01-20\", \"end\": \"2025-03-31\", \"color\": \"rgba(192, 0, 0, 0.1)\"}\n",
        "]\n",
        "\n",
        "for admin in administrations:\n",
        "    fig.add_shape(\n",
        "        type=\"rect\",\n",
        "        x0=admin[\"start\"],\n",
        "        x1=admin[\"end\"],\n",
        "        y0=y_min,\n",
        "        y1=y_max,\n",
        "        fillcolor=admin[\"color\"],\n",
        "        line=dict(width=0),\n",
        "        layer=\"below\"\n",
        "    )\n",
        "    fig.add_annotation(\n",
        "        x=pd.to_datetime(admin[\"start\"]) + (pd.to_datetime(admin[\"end\"]) - pd.to_datetime(admin[\"start\"])) / 2,\n",
        "        y=y_max - 0.3,\n",
        "        text=admin[\"name\"],\n",
        "        showarrow=False,\n",
        "        font=dict(size=10)\n",
        "    )\n",
        "\n",
        "# Final layout\n",
        "fig.update_layout(\n",
        "    title=\"Monthly Average AFINN Tone by News Network (2015–2025)\",\n",
        "    xaxis_title=\"Date\",\n",
        "    yaxis_title=\"AFINN Tone Score\",\n",
        "    yaxis=dict(range=[y_min, y_max], gridcolor=\"#E5E5E5\"),\n",
        "    xaxis=dict(tickformat=\"%Y\", gridcolor=\"#E5E5E5\"),\n",
        "    legend_title=\"News Networks\",\n",
        "    plot_bgcolor=\"white\",\n",
        "    width=900,\n",
        "    height=500,\n",
        "    margin=dict(l=50, r=50, t=80, b=80)\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "fig-static-monthly-afinn-clean",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| label: fig-static-monthly-vader\n",
        "#| fig-cap: Monthly average VADER tone trends by news network (2015–2025)\n",
        "\n",
        "import plotly.graph_objects as go\n",
        "import pandas as pd\n",
        "\n",
        "# Ensure 'month' is timestamp (for Period \n",
        "\n",
        "# Create continuous monthly date range\n",
        "all_months = pd.date_range(start=df['month'].min(), end=df['month'].max(), freq='MS')\n",
        "\n",
        "# Fill missing months with NaNs and compute monthly averages\n",
        "monthly_vader_full = (\n",
        "    df.set_index('month')\n",
        "      .groupby('network')['vader_tone_score']\n",
        "      .resample('MS')\n",
        "      .mean()\n",
        "      .unstack(0)\n",
        "      .reindex(all_months)\n",
        "      .reset_index()\n",
        "      .rename(columns={'index': 'month'})\n",
        ")\n",
        "\n",
        "# Define network colors\n",
        "NETWORK_COLORS = {\n",
        "    'MSNBC': '#3366CC',\n",
        "    'ABC News': '#6633CC',\n",
        "    'Fox News': '#CC3366'\n",
        "}\n",
        "\n",
        "# Get y-axis range\n",
        "y_min = monthly_vader_full.iloc[:, 1:].min().min() - 0.05\n",
        "y_max = monthly_vader_full.iloc[:, 1:].max().max() + 0.05\n",
        "\n",
        "# Initialize plot\n",
        "fig = go.Figure()\n",
        "\n",
        "# Plot each network\n",
        "for network in ['MSNBC', 'ABC News', 'Fox News']:\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=monthly_vader_full['month'],\n",
        "            y=monthly_vader_full[network],\n",
        "            mode=\"lines+markers\",\n",
        "            name=network,\n",
        "            line=dict(color=NETWORK_COLORS[network], width=4),\n",
        "            connectgaps=True\n",
        "        )\n",
        "    )\n",
        "\n",
        "# Add neutral line at y=0\n",
        "fig.add_shape(\n",
        "    type=\"line\",\n",
        "    x0=monthly_vader_full['month'].min(),\n",
        "    x1=monthly_vader_full['month'].max(),\n",
        "    y0=0,\n",
        "    y1=0,\n",
        "    line=dict(color=\"black\", width=2, dash=\"dash\")\n",
        ")\n",
        "\n",
        "# Administration shading\n",
        "administrations = [\n",
        "    {\"name\": \"Obama Admin\", \"start\": \"2015-01-01\", \"end\": \"2017-01-19\", \"color\": \"rgba(0, 112, 192, 0.1)\"},\n",
        "    {\"name\": \"Trump 1st Term\", \"start\": \"2017-01-20\", \"end\": \"2021-01-19\", \"color\": \"rgba(192, 0, 0, 0.1)\"},\n",
        "    {\"name\": \"Biden Admin\", \"start\": \"2021-01-20\", \"end\": \"2025-01-19\", \"color\": \"rgba(0, 112, 192, 0.1)\"},\n",
        "    {\"name\": \"Trump 2nd Term\", \"start\": \"2025-01-20\", \"end\": \"2025-03-31\", \"color\": \"rgba(192, 0, 0, 0.1)\"}\n",
        "]\n",
        "\n",
        "for admin in administrations:\n",
        "    fig.add_shape(\n",
        "        type=\"rect\",\n",
        "        x0=admin[\"start\"],\n",
        "        x1=admin[\"end\"],\n",
        "        y0=y_min,\n",
        "        y1=y_max,\n",
        "        fillcolor=admin[\"color\"],\n",
        "        line=dict(width=0),\n",
        "        layer=\"below\"\n",
        "    )\n",
        "    fig.add_annotation(\n",
        "        x=pd.to_datetime(admin[\"start\"]) + (pd.to_datetime(admin[\"end\"]) - pd.to_datetime(admin[\"start\"])) / 2,\n",
        "        y=y_max - 0.02,\n",
        "        text=admin[\"name\"],\n",
        "        showarrow=False,\n",
        "        font=dict(size=10)\n",
        "    )\n",
        "\n",
        "# Final layout\n",
        "fig.update_layout(\n",
        "    title=\"Monthly Average VADER Tone by News Network (2015–2025)\",\n",
        "    xaxis_title=\"Date\",\n",
        "    yaxis_title=\"VADER Tone Score\",\n",
        "    yaxis=dict(range=[y_min, y_max], gridcolor=\"#E5E5E5\"),\n",
        "    xaxis=dict(tickformat=\"%Y\", gridcolor=\"#E5E5E5\"),\n",
        "    legend_title=\"News Networks\",\n",
        "    plot_bgcolor=\"white\",\n",
        "    width=900,\n",
        "    height=500,\n",
        "    margin=dict(l=50, r=50, t=80, b=80)\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "fig-static-monthly-vader",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/miniconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}